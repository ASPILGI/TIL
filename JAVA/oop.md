# 객체 지향 프로그래밍(Object Oriented Programming)

- 객체 지향 프로그래밍은 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고<br>
  그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.
```
객체(object)란
- 간단히 이야기해서 실생활에서 우리가 인식할 수 있는 사물로 설명할 수 있다.
- 이러한 객체의 행동을 구체화하는 형태의 프로그래밍이 바로 객체 지향 프로그래밍이다.
```

## 객체 지향 프로그래밍의 장,단점
> 장점
- 코드 재사용이 용이
  - 남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있다.
- 유지보수가 쉬움
  - 절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야 하는 반면<br>
    객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버변수 혹은 메서드로 존재하기 때문에 해당 부분만 수정하면 된다. 
- 대형 프로젝트에 적합
  - 클래스 단위로 모듈화시켜서 개발할 수 있으므로 업무 분담하기 쉽다.

> 단점
- 처리 속도가 상대적으로 느림
- 객체가 많으면 용량이 커질 수 있음
- 설계시 많은 시간과 노력이 필요함

## 객체 지향 프로그래밍 키워드 5가지
1. 클래스 + 인스턴스(객체)
2. 추상화
3. 캡슐화
4. 상속
5. 다형성

### 1. 클래스 + 객체(인스턴스)

- 클래스 : 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
- 객체 : 객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
- 인스턴스 : 인스턴스는 객체에 메모리가 할당되어 실제로 활용되는 실체입니다.
```
예시)
1. 동물이라는 클래스를 만들고 
2. 그 기반으로 고양이와 개라는 객체를 생성합니다
3. 거기서 고양이와 개라는 객체를 메모리에 할당시켜 실제로 활용되는 실체가 인스턴스입니다.
```

### 2. 추상화
- 객체들의 "공통" 속성이나 기능을 묶어 이름을 붙이는 것이다.<br>예를 들어, 강아지나 고양이의 공통적인 부분을 묶어 pet이라는 이름을 붙이는 것

### 3. 캡슐화
- 캡슐화란 객체 지향 프로그래밍에서 기능과 특성의 모음을 "클래스"라는 "캡슐"에 분류해서 넣는 것입니다. 
```
캡슐화의 목적 2가지
1. 코드를 재수정 없이 재활용하는 것.
2. 접근 제어자를 통한 정보 은닉
```

### 4. 상속
- 상속은 부모 클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게 하고 기능의 일부분을 변경해야 할 경우<br> 상속받은 자식 클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다.
```
다중상속은 불가하다. 
(클래스의 상속 관계에서 혼란을 줄 수 있기 때문에 상속은 반드시 하나만 가능하고 필요에 따라 인터페이스를 사용할 수 있게 했다.)
```

### 5. 다형성
자바에서 다형성을 지원하는 방법으로 메소드 오버로딩(Overloading) 오버라이딩(Overriding)이 있다.

오버로딩(Overloading) : 같은 이름의 메소드를 여러 개 가지면서 매개변수의 유형과 개수가 다르도록 하는 기술

오버라이딩(Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의 해서 한다.

**1. 오버로딩 (Overloading)**

같은 이름의 메서드 여러개를 매개변수 유형과 개수의 차이로 구별하는 것으로, 메서드 오버로딩과 생성자 오버로딩으로 나뉜다.

같은 이름의 메서드 또는 생성자를 여러개 정의하고, 매개변수의 자료형과 개수 등을 다르게 하여, 다양한 유형의 호출에 응답할 수 있게된다
```java
public class Overloadingtest {
	// test() 호출
    void test(){
        System.out.println("매개변수 없음");
    }

    // test에 매개변수로 int형 2개 호출
    void test(int z, int x){
        System.out.println("매개변수 "+ z + "와 " + x);
    }

    // test에 매개변수 double형 1개 호출
    void test(double d){
        System.out.println("매개변수 " + d);
    }
}
```
```java
public class test {
    public static void main(String[] args) {       
        // Overloadingtest 객체 생성
        Overloadingtest ob = new Overloadingtest();
       
        // test() 호출
        ob.test();
       
        // test(int z, int x) 호출
        ob.test(15, 40);
           
        // test(double d) 호출
        ob.test(223.5);
    }
}
```

**2. 오버라이딩 (Overriding)**

상위 클래스가 가지고 있는 메서드를 하위클래스가 재정의 하는 것

상위 클래스의 메서드와 메서드 이름, 매개변수, 반환형이 같을경우 이를 자동으로 오버라이딩으로 인식하여, 상위클래스의 메서드를 재정의한다. (덮어쓴다)

단, 매개변수의 이름은 달라도 상관없다.

```java
public class student{
   
    public String name;
    public int age;
   
    // print() 메소드
    public void print(){
        System.out.println("학생의 이름은 "+this.name+ "이고, 나이는" + this.age+"입니다.");
    }   
}


// Employee 상속
public class Manager extends Employee{
   
    String roleOfTeacher;
   
    // print() 메소드 오버라이딩
    public void print(){
        System.out.println("학생의 이름은 "+this.name + "이고, 나이는" + this.age + "입니다.");
        System.out.println("선생님 "+this.name+"은 "+this.roleOfTeacher+" 담당입니다.");
    }
}
```
```java
public class test {

    public static void main(String[] args) {
        
     // Manager 객체 생성
     Teacher lee = new Teacher();
     
     // 변수 설정   
     lee.name = "심봉사";
     lee.age = 40;
     lee.roleOfTeacher="부장선생님";
        
// Overriding된 Teacher객체의 print()호출
      lee.print();
    }
}
```

Student에 print() 함수를 선언하고, Teacher에서 Student를 상속하여 print() 메소드를 재정의 하였다.

main 함수에서 Teacher 객체를 생성 후, print() 메소드를 호출하면 오버라이딩된 Teacher 객체의 print() 메소드가 호출된다.

## 객체지향 설계 5원칙 - SOLID
- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Priciple): 개방 폐쇄 원칙
- LSP(Listov Substitution Priciple): 리스코프 치환 원칙
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존 역전 원칙

### 1. SRP(Single Responsibility Principle): 단일 책임 원칙
- 클래스는 단 한개의 책임을 가져야 함, 클래스를 변경하는 이유는 단 하나여야 함
- 이를 지키지 않으면, 한 책임(기능)의 변경에 의해 다른 책임(기능)과 관련된 코드에 영향을 미칠 수 있음<br>
  → 이렇게 되면 유지보수가 매우 비효율적
  
### 2. OCP(Open Closed Priciple): 개방 폐쇄 원칙
- 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함
- 즉, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 함
- 이를 지키지 않으면 instanceof 와 같은 연산자를 사용하거나, 다운 캐스팅 발생

### 3. LSP(Listov Substitution Priciple): 리스코프 치환 원칙
- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 함<br>
  → 즉, 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 함
- 상속관계에서는 꼭 일반화 관계(IS-A)가 성립해야 한다는 의미(일관성 있는 관계인지)
- 상속관계가 아닌 클래스들을 상속관계로 설정하면, 이 원칙이 위배됨 (재사용 목적으로 사용하는 경우)

### 4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다는 원칙
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 함<br>
  → 하나의 통상적인 인터페이스보다는 차라리 여러 개의 세부적인 (구체적인) 인터페이스가 나음
- 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 함

### 5. DIP(Dependency Inversion Principle): 의존 역전 원칙
- 의존 관계를 맺을 때, 변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 함<br>
  -> → 구체화된 클래스에 의존하기 보다는 추상 클래스나 인터페이스에 의존해야 한다는 뜻
  
```
총 정리
- SRP 와 ISP 는 객체가 커지는 것을 막아준다. 객체가 단일 책임을 갖도록 하고 클라이언트마다 특화된 인터페이스를 구현하게 함으로써
한 기능의 변경이 다른 곳까지 미치는 영향을 최소화하고, 이는 기능 추가 및 변경에 용이하도록 만들어 준다.

- LSP 와 DIP 는 OCP 를 서포트한다. OCP 는 자주 변화되는 부분을 추상화하고 다형성을 이용함으로써 
기능 확장에는 용이하되 기존 코드의 변화에는 보수적이도록 만들어 준다. 여기서 '변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP 이고, 
다형성 구현을 도와주는 원칙이 LSP 인 것이다.
```
